use std::vec;

use actix_web::{web, App, HttpResponse, HttpServer, HttpRequest, Responder, Result, get};
use insolvent_detect_signal::types::TransferFromFixedFloatJson;
use serde::{Deserialize, Serialize};

struct FakeDB;

impl FakeDB {
    pub fn list_events(&self) -> Vec<Event> {
        vec![Event{ id: 10, name: "TransferFromFixedFloat".to_string() }, Event{ id: 11, name: "SuspiciousContractCreated".to_string() }]
    }

    pub fn logged_events(&self) -> Vec<LoggedEvent> {
        //This is generated by signals, is the payload saved in the db
        let fake_event_json = TransferFromFixedFloatJson {
            recipient: "fake".to_string(),
            value: 10,
            block_timestamp: 10,
            block: 10,
            transaction_hash: "fake_hash".to_string(),
        };

        let fake_event = LoggedEvent{
            id: 100,
            message: serde_json::to_value(fake_event_json).unwrap(),
        };

        vec![fake_event]
    }
}

#[derive(Debug, Deserialize, Serialize)]
struct Event {
    id: u64,
    name: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct LoggedEvent {
    id: u64,
    message: serde_json::Value,
}

#[derive(Debug, Deserialize, Serialize)]
struct LoggedEventsResponse {
    logged_events: Vec<LoggedEvent>,
}

#[get("/logged_events")]
async fn logged_events(_req: HttpRequest, db: web::Data<FakeDB>) -> Result<impl Responder> {
    Ok(web::Json(LoggedEventsResponse { logged_events: db.logged_events() }))
}

#[derive(Debug, Deserialize, Serialize)]
struct ListEventsResponse {
    events: Vec<Event>,
}

#[get("/list_events")]
async fn list_events(_req: HttpRequest, db: web::Data<FakeDB>) -> Result<impl Responder> {
    Ok(web::Json(ListEventsResponse { events: db.list_events() }))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| 
            App::new()
                .app_data(web::Data::new(FakeDB))
                .route("/", web::get()
                .to(HttpResponse::Ok))
        )
        .bind(("127.0.0.1", 8080))?
        .run()
        .await
}

#[cfg(test)]
mod tests {
    use actix_web::{test, App, body};

    use super::*;

    #[actix_web::test]
    async fn test_list_events() {
        let app = test::init_service(App::new().app_data(web::Data::new(FakeDB)).service(list_events).service(logged_events)).await;
        let req = test::TestRequest::get().uri("/list_events").to_request();
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());

        let body = body::to_bytes(resp.into_body()).await.unwrap();
        let str = std::str::from_utf8(&body).unwrap();
        let events = serde_json::from_str::<ListEventsResponse>(str).unwrap();

        assert_eq!(events.events.get(0).unwrap().id, 10);
        assert_eq!(events.events.get(1).unwrap().id, 11);
    }

    #[actix_web::test]
    async fn test_logged_events() {
        let app = test::init_service(App::new().app_data(web::Data::new(FakeDB)).service(list_events).service(logged_events)).await;
        let req = test::TestRequest::get().uri("/logged_events").to_request();
        let resp = test::call_service(&app, req).await;
        assert!(resp.status().is_success());

        let body = body::to_bytes(resp.into_body()).await.unwrap();
        let str = std::str::from_utf8(&body).unwrap();
        let events = serde_json::from_str::<LoggedEventsResponse>(str).unwrap();

        assert_eq!(events.logged_events.get(0).unwrap().id, 100);
    }
}